<script lang="ts">
	import { writable, type Writable } from 'svelte/store';
	// Docs
	import DocsShell from '../../DocsShell/DocsShell.svelte';
	import { DocsFeature, type DocsShellSettings } from '../../DocsShell/types';
	import DocsPreview from '../../DocsPreview/DocsPreview.svelte';
	// Types
	import type { TableSource } from '$lib/components/DataDisplay/Table/types';
	// Utils
	import { tableMapperValues } from '$lib/components/DataDisplay/Table/utils';
	// Components
	import Table from '$lib/components/DataDisplay/Table/Table.svelte';
	import TabGroup from '$lib/components/Navigation/Tab/TabGroup.svelte';
	import Tab from '$lib/components/Navigation/Tab/Tab.svelte';
	// Utilities
	import CodeBlock from '$lib/components/DataDisplay/CodeBlock/CodeBlock.svelte';
	// Sveld
	import sveldTable from '$lib/components/DataDisplay/Table/Table.svelte?raw&sveld';

	// Stores
	let storeService: Writable<string> = writable('tableMapperValues');

	// Docs Shell
	const settings: DocsShellSettings = {
		feature: DocsFeature.Component,
		name: 'Tables',
		description: 'Utilize a data-driven model to create simple presentational tables.',
		imports: ['Table'],
		types: ['TableSource'],
		source: 'components/Table',
		aria: 'https://www.w3.org/WAI/ARIA/apg/patterns/grid/',
		components: [{ sveld: sveldTable }],
		keyboard: [
			[
				'<kbd>Right Arrow</kbd>',
				'Moves focus one cell to the right. If focus is on the right-most cell in the row, focus does not move.'
			],
			[
				'<kbd>Left Arrow</kbd>',
				'Moves focus one cell to the left. If focus is on the left-most cell in the row, focus does not move.'
			],
			[
				'<kbd>Down Arrow</kbd>',
				'Moves focus one cell down. If focus is on the bottom cell in the column, focus does not move.'
			],
			[
				'<kbd>Up Arrow</kbd>',
				'Moves focus one cell Up. If focus is on the top cell in the column, focus does not move.'
			],
			['<kbd>Home</kbd>', 'Moves focus to the first cell in the row that contains focus.'],
			['<kbd>End</kbd>', ' Moves focus to the last cell in the row that contains focus.'],
			['<kbd>Enter</kbd> or <kbd>Space</kbd>', 'Triggers the on:selected event.']
		]
	};

	// Local
	const sourceData = [
		{ position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H' },
		{ position: 2, name: 'Helium', weight: 4.0026, symbol: 'He' },
		{ position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li' },
		{ position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be' },
		{ position: 5, name: 'Boron', weight: 10.811, symbol: 'B' }
		// { position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C' },
		// { position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N' },
		// { position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O' },
		// { position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F' },
		// { position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne' }
	];
	const totalWeight = sourceData.reduce((accumulator, obj) => accumulator + obj.weight, 0);

	// Table Simple
	const tableSimple: TableSource = {
		head: ['Symbol', 'Name', 'Weight'],
		body: tableMapperValues(sourceData, ['symbol', 'name', 'weight']),
		meta: tableMapperValues(sourceData, ['position', 'name', 'symbol', 'weight']),
		foot: ['Total', '', `<span class="badge variant-soft-primary">${totalWeight}</span>`]
	};

	// On Row Selected
	function onSelected(meta: any): void {
		console.log('on:selected', meta);
	}
</script>

<DocsShell {settings}>
	<section class="flex flex-col gap-4">
		<DocsPreview>
			<svelte:fragment slot="bcu-previewer-preview">
				<Table source={tableSimple} interactive={true} on:selected={onSelected} text="text-token" />
			</svelte:fragment>
			<svelte:fragment slot="bcu-previewer-footer">
				<p class="block text-center">Try viewing your console log when tapping a row.</p>
			</svelte:fragment>
			<svelte:fragment slot="bcu-previewer-source">
				<p>First, you'll need a set of source data.</p>
				<CodeBlock
					language="ts"
					code={`
const sourceData = [
	{ position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H' },
	{ position: 2, name: 'Helium', weight: 4.0026, symbol: 'He' },
	{ position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li' },
	{ position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be' },
	{ position: 5, name: 'Boron', weight: 10.811, symbol: 'B' },
];
				`}
				/>
				<p>
					Create a <code>TableSource</code> object. use
					<code>body: tableMapperValues(sourceData)</code> to map the data.
				</p>
				<CodeBlock
					language="ts"
					code={`
const tableSimple: TableSource = {
	// A list of heading labels.
	head: ['Name', 'Symbol', 'Weight'],
	// The data visibly shown in your table body UI.
	body: tableMapperValues(sourceData, ['name', 'symbol', 'weight']),
	// Optional: The data returned when interactive is enabled and a row is clicked.
	meta: tableMapperValues(sourceData, ['position', 'name', 'symbol', 'weight']),
	// Optional: A list of footer labels.
	foot: ['Total', '', '<code>${totalWeight}</code>']
};
				`}
				/>
				<p>Finally, we pass our table source data to the component for display.</p>
				<CodeBlock language="html" code={`<Table source={tableSimple} />`} />
			</svelte:fragment>
		</DocsPreview>
		<section class="space-y-4">
			<h2>Interactive Mode</h2>
			<p>
				Use the <code>interactive</code> to make the table interactive. When a row is clicked,
				<code>on:selected</code>
				will pass the row's
				<code>meta</code> value.
			</p>
			<CodeBlock
				language="html"
				code={`<Table ... interactive={true} on:selected={mySelectionHandler} />`}
			/>
		</section>
		<!-- Table Utilities -->
		<section class="space-y-4">
			<h2>Table Utilities</h2>
			<p>
				The following utility methods allow you to format your source data for use within a Table
				component.
			</p>
			<TabGroup>
				<Tab bind:group={$storeService} name="tableMapperValues" value="tableMapperValues"
					>Mapper Values</Tab
				>
				<Tab bind:group={$storeService} name="tableSourceMapper" value="tableSourceMapper"
					>Source Mapper</Tab
				>
				<Tab bind:group={$storeService} name="tableSourceValues" value="tableSourceValues"
					>Source Values</Tab
				>
			</TabGroup>
			<CodeBlock
				language="ts"
				code={`import { ${$storeService} } from '@codingcatdev/blackcatui';`}
			/>
			{#if $storeService === 'tableMapperValues'}
				<!-- Table Mapper Values -->
				<p>
					Combines Source Mapper and Source Values methods to handle both operations at once. This
					allows you to use the same source object, but format differently between display (body)
					and selected response (meta). It's recommended to use this in most use cases.
				</p>
				<CodeBlock
					language="ts"
					code={`
tableMapperValues(sourceData, ['name', 'symbol', 'weight'])\n
//	[
//		['Hydrogen', 'H', '1.0079'],
//		['Helium', 'He', '4.0026'],
//		...
//	]
				`}
				/>
			{:else if $storeService === 'tableSourceMapper'}
				<!-- Source Mapper -->
				<p>Allows you to both whitelist object keys and map the order of display.</p>
				<CodeBlock
					language="ts"
					code={`
tableSourceMapper(sourceData, ['name', 'symbol', 'weight']);\n
//[
//		{ name: 'Hydrogen', symbol: 'H', weight: '1.0079' },
//		{ name: 'Helium', symbol: 'He', weight: '4.0026' },
//		...
//]
					`}
				/>
			{:else if $storeService === 'tableSourceValues'}
				<!-- Source Values -->
				<p>
					Returns an array of array values from an array of objects. This is the desired format for <code
						>TableSource</code
					> <em>body</em>
					and <em>meta</em>.
				</p>
				<CodeBlock
					language="ts"
					code={`
tableSourceValues(sourceData);\n
//[
//		[ 1, 'Hydrogen', '1.0079', 'H' ],
//		[ 2, 'Helium', '4.0026', 'He' ],
//		...
//]
`}
				/>
			{/if}
		</section>
	</section>
</DocsShell>
